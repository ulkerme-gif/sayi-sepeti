<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sayı Sepeti - Mete ÜLKER</title>
<style>
  /* Basit düzen */
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:Arial,Helvetica,sans-serif;background:#87CEEB;display:flex;flex-direction:column;align-items:center}
  #info{width:400px;text-align:center;margin-top:10px;color:#222}
  canvas{border:3px solid #ff9800;margin-top:10px;background:transparent;touch-action:none}
  /* Basit animasyon için yardımcı */
  .hidden{display:none}
</style>
</head>
<body>
  <div id="info">
    <h2>🎯 Sayı Sepeti</h2>
    <div>Yapan: <strong>Mete ÜLKER</strong></div>
    <p>Aşama: <span id="uiLevel">1</span> | Puan: <span id="uiScore">0</span></p>
  </div>

  <canvas id="canvas" width="400" height="500"></canvas>

<script>
// =====================
// Sabitler ve durum
// =====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const GROUND_Y = 450;

let basket = { x: 170, y: 420, w: 60, h: 30 };
let score = 0;
let level = 1;
let baseSpeed = 3;
let gameState = 'start'; // 'start' | 'level' | 'playing' | 'won'
let numbers = [];      // array of { x,y,deger,tip,dogru }
let blackBalls = [];   // array of { x,y,r }
let waveTimers = [];   // current wave timeouts (so we can clear them)
let waveActive = false;

// efektler
let effects = {
  greenPulses: [], // {x,y,r,alpha}
  redShake: 0,
  levelBursts: [],
  skyPhase: 0
};

// UI
const uiLevel = document.getElementById('uiLevel');
const uiScore = document.getElementById('uiScore');

// =====================
// Yardımcı fonksiyonlar
// =====================
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function randomXAvoid(existing){
  let x, tries=0;
  do { x = randInt(20, W-20); tries++; } while(existing.some(p => Math.abs(p-x) < 60) && tries < 60);
  return x;
}
function makeRational(min=-2,max=2){
  const paydaOptions=[2,3,4];
  const pay=randInt(min,max)||1;
  const payda=paydaOptions[randInt(0,paydaOptions.length-1)];
  return pay + '/' + payda;
}
function isRationalString(v){ return (typeof v === 'string' && v.includes('/')); }

// hız hesaplama (aşama arttıkça artar)
function currentSpeed(){ return baseSpeed + (level-1); }

// efekt yardımcıları
function addGreenPulse(x,y){ effects.greenPulses.push({x,y,r:6,alpha:1}); }
function addRedShake(ms=220){ effects.redShake = Math.max(effects.redShake, ms); }
function addLevelBurst(x,y){ effects.levelBursts.push({x,y,r:8,alpha:1}); }

// clear wave timers
function clearWaveTimers(){
  while(waveTimers.length){ const t = waveTimers.shift(); clearTimeout(t); }
  waveActive = false;
}

// reset oyun (tam sıfırlama)
function resetGame(){
  clearWaveTimers();
  numbers = []; blackBalls = [];
  score = 0; level = 1; baseSpeed = 3;
  gameState = 'start';
  uiLevel.innerText = level; uiScore.innerText = score;
  effects.levelBursts.push({x: W/2, y: H/2, r: 8, alpha: 1});
}

// =====================
// Oyun dalga üretimi (sağlam, tek dalga -> hiçbir zaman milyon sayıya çıkmaz)
// - 1. sayı hemen spawn
// - 2. sayı 1s sonra spawn (aynı dalga içinde)
// - siyah top(lar) 0.5s sonra spawn (3. aşamada 2 top, az küçük aralıkla)
// =====================
function spawnWave(){
  if(waveActive || gameState !== 'playing') return;
  waveActive = true;
  // temizle eski timers listesi
  clearWaveTimers();

  // pozisyon çakışmalarını engelle
  const existingX = numbers.map(n=>n.x).concat(blackBalls.map(b=>b.x));

  // 1. sayı
  const s1 = generateNumber(0, existingX);
  numbers.push(s1);
  existingX.push(s1.x);

  // 2. sayı 1s sonra
  const t1 = setTimeout(()=>{
    if(gameState !== 'playing') return;
    const s2 = generateNumber(1, existingX);
    numbers.push(s2);
    existingX.push(s2.x);
  }, 1000);
  waveTimers.push(t1);

  // siyah top(lar) 0.5s sonra (asama3 => 2 top)
  const blackCount = (level === 3 ? 2 : 1);
  for(let i=0;i<blackCount;i++){
    const t = setTimeout(()=>{
      if(gameState !== 'playing') return;
      // avoid positions
      const bx = randomXAvoid(existingX);
      blackBalls.push({ x: bx, y: -20, r: 16 });
      existingX.push(bx);
    }, 500 + i*120); // ayırmak için küçük gecikme
    waveTimers.push(t);
  }

  // dalga tamamlandı bildirimi (yine güvenlik amaçlı): 1.6s sonra waveActive false olur,
  // ama yeni dalga üretme koşulumuz numbers ve blackBalls dizilerinin boş olması olacak,
  // bu sadece bir guard.
  const tDone = setTimeout(()=>{ waveActive = false; }, 1600);
  waveTimers.push(tDone);
}

// sayı üretimi (kurallara göre)
function generateNumber(index, existingX){
  // existingX passed for avoiding overlaps
  const pos = randomXAvoid(existingX || []);
  let item = { x: pos, y: -30, deger: null, tip: null, dogru: false };
  if(level === 1){
    if(index === 0){
      item.deger = randInt(0,9);
      item.tip = 'natural';
      item.dogru = true;
    } else {
      if(Math.random() < 0.5){
        item.deger = -randInt(1,9);
        item.tip = 'negative';
        item.dogru = false;
      } else {
        item.deger = makeRational();
        item.tip = 'rational';
        item.dogru = false; // in level1 rational is wrong (damaging)
      }
    }
  } else if(level === 2){
    if(index === 0){
      item.deger = randInt(-10,10);
      item.tip = 'integer';
      item.dogru = true;
    } else {
      item.deger = makeRational();
      item.tip = 'rational';
      item.dogru = false; // wrong in level2
    }
  } else {
    // level 3: all rationals are correct
    item.deger = makeRational();
    item.tip = 'rational';
    item.dogru = true;
  }
  return item;
}

// =====================
// Çizim fonksiyonları
// =====================

function drawBackground(){
  // sky gradient by level
  let topColor = '#bfe9ff', bottomColor = '#87CEEB';
  if(level === 1){ topColor = '#bfe9ff'; bottomColor = '#87CEEB'; }
  else if(level === 2){ topColor = '#87CEEB'; bottomColor = '#66b3ff'; }
  else { topColor = '#ffcc99'; bottomColor = '#ff9966'; }

  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, topColor);
  g.addColorStop(1, bottomColor);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // ground
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
}

// start / level / win screens
function drawStartScreen(){
  drawBackground();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'white';
  ctx.font = '22px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Oyuna başlamak için tıklayın / dokunun', W/2, H/2);
  ctx.fillText('(Sepeti ok tuşlarıyla veya parmakla hareket ettirin)', W/2, H/2 + 30);
}

function drawLevelScreen(){
  drawBackground();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'white';
  ctx.font = '22px Arial';
  ctx.textAlign = 'center';
  let txt = '';
  if(level === 1) txt = 'Aşama 1: Doğal sayılar';
  else if(level === 2) txt = 'Aşama 2: Tam sayılar';
  else txt = 'Aşama 3: Rasyonel sayılar';
  ctx.fillText(txt, W/2, H/2 - 10);
  ctx.fillText('Başlamak için dokunun', W/2, H/2 + 20);
}

function drawWinScreen(){
  drawBackground();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('🎉 Tebrikler, oyunu kazandınız!', W/2, H/2 - 10);
  ctx.fillText('Tekrar oynamak için dokunun', W/2, H/2 + 20);
}

function drawGameObjects(){
  // basket (shake if red)
  let shakeX = 0;
  if(effects.redShake > 0) shakeX = Math.sin(Date.now()/30) * 4;

  ctx.fillStyle = '#FF8C00';
  ctx.fillRect(basket.x + shakeX, basket.y, basket.w, basket.h);
  ctx.fillStyle = '#FFB74D';
  ctx.fillRect(basket.x - 5 + shakeX, basket.y - 15, basket.w + 10, 10);

  // numbers
  ctx.font = '28px Arial';
  ctx.textBaseline = 'middle';
  numbers.forEach(n => {
    ctx.fillStyle = (n.tip === 'rational' ? '#00695c' : '#1565c0');
    ctx.fillText(String(n.deger), n.x, n.y);
  });

  // black balls
  blackBalls.forEach(b => {
    ctx.fillStyle = 'black';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  });

  // effects: green pulses
  effects.greenPulses.forEach(p => {
    ctx.beginPath();
    ctx.fillStyle = `rgba(0,200,0,${p.alpha*0.45})`;
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  });

  // level bursts
  effects.levelBursts.forEach(b => {
    ctx.beginPath();
    ctx.strokeStyle = `rgba(255,220,100,${b.alpha})`;
    ctx.lineWidth = 3;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.stroke();
  });
}

// =====================
// Güncelleme (physics + mantık)
// =====================
function update(deltaMs){
  // efekt süreleri
  if(effects.redShake > 0) effects.redShake = Math.max(0, effects.redShake - deltaMs);
  effects.greenPulses.forEach(p => { p.r += 6 * (deltaMs/16); p.alpha -= 0.06 * (deltaMs/16); });
  effects.greenPulses = effects.greenPulses.filter(p => p.alpha > 0 && p.r < 200);
  effects.levelBursts.forEach(b => { b.r += 10 * (deltaMs/16); b.alpha -= 0.04 * (deltaMs/16); });
  effects.levelBursts = effects.levelBursts.filter(b => b.alpha > 0 && b.r < 400);

  if(gameState !== 'playing') return;

  const spd = currentSpeed();

  // hareket
  numbers.forEach(n => n.y += spd * (deltaMs/16));
  blackBalls.forEach(b => b.y += spd * (deltaMs/16));

  // çarpışma: sayılar
  for(let i = numbers.length - 1; i >= 0; i--){
    const s = numbers[i];
    const caught = (s.y > basket.y - 18 && s.x > basket.x - 8 && s.x < basket.x + basket.w + 8);
    if(caught){
      // davranış kuralları:
      // - eğer rasyonel ve level < 3 => -10 (damage)
      // - eğer dogru ise +10
      // - diğer yanlışlar => no points (sadece hafif kırmızı uyarı)
      if(s.tip === 'rational' && level < 3){
        score -= 10;
        addRedShake(220);
      } else if(s.dogru){
        score += 10;
        addGreenPulse(basket.x + basket.w/2, basket.y);
      } else {
        // yanlış ama puan vermez
        addRedShake(140);
      }
      numbers.splice(i,1);
      if(score < 0){ resetGame(); return; }
      uiScore.innerText = score;
      continue;
    }
    // yere düştü
    if(s.y > GROUND_Y + 10){
      // yanlışlar yere düşsün -> no points/give nothing
      numbers.splice(i,1);
      continue;
    }
  }

  // çarpışma: siyah toplar
  for(let i = blackBalls.length - 1; i >= 0; i--){
    const b = blackBalls[i];
    const caught = (b.y > basket.y - 8 && b.x > basket.x - 8 && b.x < basket.x + basket.w + 8);
    if(caught){
      score -= 10;
      addRedShake(260);
      blackBalls.splice(i,1);
      if(score < 0){ resetGame(); return; }
      uiScore.innerText = score;
      continue;
    }
    if(b.y > GROUND_Y + 10){
      blackBalls.splice(i,1);
      continue;
    }
  }

  // eğer hem arrays boşsa ve waveActive false ise yeni dalga başlat
  if(numbers.length === 0 && blackBalls.length === 0 && !waveActive){
    // 600ms sonra yeni dalga başlat (ama tek bir timeout olacak, waveActive kontrolü spawnWave içinde)
    const t = setTimeout(()=>{ if(gameState === 'playing') spawnWave(); }, 600);
    waveTimers.push(t);
  }

  // seviye atlama
  if(score >= 60){
    // level up
    score = 0;
    level++;
    uiLevel.innerText = Math.min(level, 3);
    uiScore.innerText = score;
    clearWaveTimers(); numbers = []; blackBalls = [];
    // eğer level > 3 --> kazanma
    if(level > 3){
      gameState = 'won';
      addLevelBurst(W/2, H/2);
      return;
    } else {
      // show level screen
      gameState = 'level';
      // increase base speed a bit
      baseSpeed += 1;
      addLevelBurst(W/2, H/2);
      return;
    }
  }

  // normalleştirme
  if(score < 0) score = 0; // safe-guard
  uiScore.innerText = score;
}

// =====================
// Oyun döngüsü
// =====================
let lastTs = performance.now();
function loop(ts){
  const delta = ts - lastTs;
  lastTs = ts;

  // draw
  if(gameState === 'start') drawStartScreen();
  else if(gameState === 'level') drawLevelScreen();
  else if(gameState === 'won') drawWinScreen();
  else {
    drawBackground();
    drawGameObjects();
  }

  update(delta);

  requestAnimationFrame(loop);
}

// =====================
// Input kontrolleri
// =====================
window.addEventListener('keydown', (e) => {
  if(gameState !== 'playing') return;
  if(e.key === 'ArrowLeft') { basket.x -= 20; }
  if(e.key === 'ArrowRight') { basket.x += 20; }
  basket.x = clamp(basket.x, 0, W - basket.w);
});
let touchStartX = null;
canvas.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  if(gameState !== 'playing'){ // start/level/won ekran dokunma davranışı
    if(gameState === 'start'){ startPlaying(); return; }
    if(gameState === 'level'){ startPlaying(); return; }
    if(gameState === 'won'){ resetGame(); return; }
  } else {
    touchStartX = ev.touches[0].clientX;
  }
});
canvas.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  if(gameState !== 'playing' || touchStartX === null) return;
  const nx = ev.touches[0].clientX;
  const dx = nx - touchStartX;
  basket.x += dx;
  basket.x = clamp(basket.x, 0, W - basket.w);
  touchStartX = nx;
});
canvas.addEventListener('touchend', (ev) => { touchStartX = null; });

// mouse click for start/level/win or to move basket on desktop
canvas.addEventListener('click', (ev) => {
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  if(gameState === 'start'){ startPlaying(); return; }
  if(gameState === 'level'){ startPlaying(); return; }
  if(gameState === 'won'){ resetGame(); return; }
  // if in-game and click on left/right half, move basket a bit (convenience)
  if(gameState === 'playing'){
    if(x < W/2) basket.x -= 30; else basket.x += 30;
    basket.x = clamp(basket.x, 0, W - basket.w);
  }
});

// Başlatma fonksiyonu
function startPlaying(){
  clearWaveTimers();
  numbers = []; blackBalls = [];
  score = score; // keep current score (usually 0 after level up)
  uiScore.innerText = score;
  uiLevel.innerText = Math.min(level,3);
  gameState = 'playing';
  // kısa bir delay ile dalga başlat
  setTimeout(()=>{ if(gameState === 'playing') spawnWave(); }, 150);
}

// =====================
// Temizleme fonksiyonu (reset için de kullanılır)
// =====================
function clearAllTimersAndState(){
  clearWaveTimers();
  numbers = []; blackBalls = [];
  effects = { greenPulses: [], redShake: 0, levelBursts: [], skyPhase: 0 };
}

// =====================
// Başlangıç
// =====================
uiLevel.innerText = level;
uiScore.innerText = score;
requestAnimationFrame(loop);

// =====================
// Yardımcı: addLevelBurst wrapper with push
// =====================
function addLevelBurst(x,y){
  effects.levelBursts.push({x,y,r:8,alpha:1});
}

// =====================
// Başlangıç reset (önceki verileri temizle)
// =====================
resetGame(); // set initial state

</script>
</body>
</html>
